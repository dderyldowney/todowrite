# ToDoWrite Database Schema and Usage Guide

## Overview

ToDoWrite uses SQLAlchemy ORM with a relational database schema to store hierarchical task management data. The schema supports 12 layers of hierarchy with rich metadata, relationships, and command execution tracking.

## Database Schema

### Core Tables

#### `nodes` Table
The central table storing all hierarchical nodes.

```sql
CREATE TABLE nodes (
    id VARCHAR PRIMARY KEY,           -- Unique node identifier with layer prefix
    layer VARCHAR NOT NULL,           -- One of 12 valid layers
    title VARCHAR NOT NULL,           -- Node title
    description TEXT,                 -- Optional description
    status VARCHAR DEFAULT 'planned', -- Node status
    progress INTEGER,                 -- Completion percentage (0-100)
    started_date VARCHAR,             -- ISO datetime when work started
    completion_date VARCHAR,          -- ISO datetime when completed
    owner VARCHAR,                    -- Person responsible for the node
    severity VARCHAR,                 -- Priority level (low, medium, high, critical)
    work_type VARCHAR,                -- Type of work (development, docs, test, etc.)
    assignee VARCHAR                  -- Person assigned to do the work
);
```

#### `links` Table
Many-to-many relationship table for parent-child node connections.

```sql
CREATE TABLE links (
    parent_id VARCHAR REFERENCES nodes(id),
    child_id VARCHAR REFERENCES nodes(id),
    PRIMARY KEY (parent_id, child_id)
);
```

#### `labels` Table
Available labels for categorizing nodes.

```sql
CREATE TABLE labels (
    label VARCHAR PRIMARY KEY         -- Unique label name
);
```

#### `node_labels` Table
Many-to-many relationship between nodes and labels.

```sql
CREATE TABLE node_labels (
    node_id VARCHAR REFERENCES nodes(id),
    label VARCHAR REFERENCES labels(label),
    PRIMARY KEY (node_id, label)
);
```

#### `commands` Table
Executable commands associated with nodes (typically Command layer nodes).

```sql
CREATE TABLE commands (
    node_id VARCHAR PRIMARY KEY REFERENCES nodes(id),
    ac_ref VARCHAR,                   -- Reference to acceptance criteria
    run TEXT                         -- Command to execute
);
```

#### `artifacts` Table
Files or outputs generated by command execution.

```sql
CREATE TABLE artifacts (
    artifact VARCHAR PRIMARY KEY,     -- Artifact filename or identifier
    command_id VARCHAR REFERENCES commands(node_id),
    PRIMARY KEY (artifact, command_id)
);
```

## 12-Layer Hierarchy

The system supports these layers with specific ID prefixes:

| Layer | Prefix | Description |
|-------|--------|-------------|
| **Goal** | `GOAL-*` | High-level project objectives |
| **Concept** | `CON-*` | Abstract ideas and design principles |
| **Context** | `CTX-*` | Environmental factors and constraints |
| **Constraints** | `CST-*` | Technical and business limitations |
| **Requirements** | `R-*` | Functional and non-functional specifications |
| **AcceptanceCriteria** | `AC-*` | Success conditions and validation |
| **InterfaceContract** | `IF-*` | API contracts and integration points |
| **Phase** | `PH-*` | Project phases and milestones |
| **Step** | `STP-*` | Sequential work items within phases |
| **Task** | `TSK-*` | Individual work assignments |
| **SubTask** | `SUB-*` | Detailed breakdown of complex tasks |
| **Command** | `CMD-*` | Executable instructions and actions |

## Node Data Structure

### Required Fields
```python
{
    "id": "GOAL-PROJECT-001",           # Unique identifier with layer prefix
    "layer": "Goal",                     # One of 12 valid layers
    "title": "Launch New Product",       # Human-readable title
    "description": "Successfully launch...",  # Detailed description
    "links": {                           # Hierarchical relationships
        "parents": [],                   # Parent node IDs
        "children": []                   # Child node IDs
    }
}
```

### Optional Fields
```python
{
    "status": "planned",                 # planned, in_progress, completed, blocked, cancelled
    "progress": 0,                       # 0-100 completion percentage
    "started_date": "2024-01-15T09:00:00Z",  # ISO 8601 datetime
    "completion_date": None,             # ISO 8601 datetime when completed
    "metadata": {
        "owner": "product-team",         # Team or person responsible
        "labels": ["release", "q1-2024"],  # Categorization tags
        "severity": "high",              # low, medium, high, critical
        "work_type": "development",      # development, docs, test, ops, etc.
        "assignee": "alice@example.com"  # Person doing the work
    },
    "command": {                         # Only for Command layer nodes
        "ac_ref": "AC-001",              # Reference to acceptance criteria
        "run": {"shell": "make test"},   # Command execution details
        "artifacts": ["test-report.html"]  # Generated files
    }
}
```

## JSON Schema Validation

The package includes a comprehensive JSON schema for validation:

```python
from todowrite.schema import TODOWRITE_SCHEMA
from jsonschema import validate

# Example node data
node_data = {
    "id": "TSK-DEVELOP-001",
    "layer": "Task",
    "title": "Implement User Authentication",
    "description": "Add OAuth2 authentication to the application",
    "status": "planned",
    "metadata": {
        "owner": "backend-team",
        "labels": ["security", "api"],
        "severity": "high",
        "work_type": "development",
        "assignee": "bob@example.com"
    },
    "links": {
        "parents": ["PH-API-001"],
        "children": ["SUB-CODE-001", "SUB-TEST-001"]
    }
}

# Validate against schema
try:
    validate(instance=node_data, schema=TODOWRITE_SCHEMA)
    print("✅ Node data is valid!")
except jsonschema.ValidationError as e:
    print(f"❌ Validation error: {e}")
```

## Database Operations

### Using the Python API

```python
from todowrite import ToDoWrite

# Initialize with SQLite
tdw = ToDoWrite("sqlite:///project.db")
tdw.init_database()

# Create nodes
goal_data = {
    "id": "GOAL-PROJECT-001",
    "layer": "Goal",
    "title": "Launch New Product",
    "description": "Successfully launch the new product in Q1",
    "metadata": {"owner": "product-team", "severity": "high"}
}
goal = tdw.[REMOVED_LEGACY_PATTERN](goal_data)

# Create linked task
task_data = {
    "id": "TSK-DESIGN-001",
    "layer": "Task",
    "title": "Design User Interface",
    "description": "Create mockups and wireframes",
    "links": {"parents": [goal.id]},
    "metadata": {"owner": "design-team", "work_type": "design"}
}
task = tdw.[REMOVED_LEGACY_PATTERN](task_data)

# Query nodes
all_goals = tdw.get_all_nodes()["Goal"]
user_tasks = tdw.get_nodes_by_layer("Task")
completed_work = tdw.get_nodes_by_status("completed")

# Update nodes
tdw.update_node(task.id, {
    "status": "in_progress",
    "progress": 75
})
```

### Using the CLI

```bash
# Initialize database
todowrite init

# Create nodes
todowrite create --layer goal --title "Launch New Product" --owner "product-team"
todowrite create --layer task --title "Design UI" --add-parent GOAL-001

# List and search
todowrite list --layer goal
todowrite search "authentication"
todowrite get TSK-001

# Update nodes
todowrite update --id TSK-001 --status completed --progress 100
```

## Schema Constraints

### ID Pattern Validation
- **Pattern**: `^(GOAL|CON|CTX|CST|R|AC|IF|PH|STP|TSK|SUB|CMD)-[A-Za-z0-9_-]+$`
- **Examples**: `GOAL-PROJECT-001`, `TSK-DEVELOP-AUTH`, `CMD-BUILD-42`

### Status Values
- `planned` - Work not started
- `in_progress` - Work currently active
- `completed` - Work finished successfully
- `blocked` - Work waiting on dependencies
- `cancelled` - Work abandoned

### Severity Levels
- `low` - Nice to have, low impact
- `medium` - Important but not critical
- `high` - Significant business impact
- `critical` - Blocks release or major functionality

### Work Types
- `architecture` - System design and planning
- `spec` - Requirements and specifications
- `interface` - API and UI design
- `validation` - Testing and verification
- `implementation` - Core development work
- `development` - General development tasks
- `docs` - Documentation and guides
- `ops` - Operations and deployment
- `refactor` - Code improvement and cleanup
- `chore` - Maintenance tasks
- `test` - Testing and quality assurance

### Command Schema (for Command layer)
```python
{
    "command": {
        "ac_ref": "AC-001",              # Must reference an acceptance criteria
        "run": {                         # Execution configuration
            "shell": "make test",        # Required: command to execute
            "workdir": "/app",          # Optional: working directory
            "env": {                    # Optional: environment variables
                "NODE_ENV": "test"
            }
        },
        "artifacts": ["coverage.xml", "test-results.html"]  # Generated files
    }
}
```

## Database Backends

### SQLite (Default)
```python
# For development and testing
tdw = ToDoWrite("sqlite:///project.db")
```

### PostgreSQL (Production)
```python
# For production deployments
tdw = ToDoWrite("postgresql://user:pass@localhost/todowrite")
```

## Schema Migration

The schema includes automatic migration support:

```python
# Initialize with automatic migration
tdw = ToDoWrite("sqlite:///project.db")
tdw.init_database()  # Creates/updates schema automatically
```

For detailed migration procedures, see [SCHEMA_MIGRATION_GUIDE.md](SCHEMA_MIGRATION_GUIDE.md).

## Performance Considerations

### Indexing
- Primary keys on all ID columns
- Foreign key constraints for relationships
- Composite indexes on frequently queried columns

### Query Optimization
- Use specific layer filters when possible
- Limit results with pagination for large datasets
- Consider database-specific optimizations for production

### Scaling
- Handles 1000+ nodes efficiently
- Supports complex hierarchical queries
- Optimized for both read and write operations

## Integration Examples

### Web Application Integration
```python
# FastAPI endpoint
@app.post("/api/nodes")
async def [REMOVED_LEGACY_PATTERN](node_data: dict):
    tdw = ToDoWrite(database_url)
    try:
        node = tdw.[REMOVED_LEGACY_PATTERN](node_data)
        return {"id": node.id, "status": "created"}
    except Exception as e:
        return {"error": str(e)}, 400
```

### CI/CD Pipeline Integration
```bash
# Validate project structure before commit
todowrite validate
todowrite export-yaml > project-structure.yaml
git add project-structure.yaml
```

### External Tool Integration
```python
# Import from external project management tools
jira_data = fetch_jira_issues()
for issue in jira_data:
    node = convert_jira_to_todowrite(issue)
    tdw.[REMOVED_LEGACY_PATTERN](node)
```
